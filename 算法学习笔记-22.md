# 算法学习笔记 
### 221
题目：给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。  
[最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/description/)   
分析：注意子序列和子串的区别，动态规划：dp[i][j]是从i到j的回文子序列的长度   
动态转移方程：if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1]+2  else dp[i][j]=max(dp[i][j-1],dp[i+1][j])   
代码：
~~~
public class So177 {
    public int longestPalindromeSubseq(String s) {
        if(s.length()<2){
            return s.length();
        }
        char[] cs=s.toCharArray();
        int len=s.length();
        int[][] dp=new int[len][len];
        for(int i=len-1;i>=0;i--){
            dp[i][i]=1;
            for(int j=i+1;j<len;j++){
                if(cs[i]==cs[j]){
                    dp[i][j]=dp[i+1][j-1]+2;
                }else {
                    dp[i][j]=Math.max(dp[i][j-1],dp[i+1][j]);
                }
            }
        }
        return dp[0][len-1];
    }
}

~~~


### 222
题目：给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

注意: 你可以假设

0 <= amount (总金额) <= 5000  
1 <= coin (硬币面额) <= 5000  
硬币种类不超过500种  
结果符合32位符号整数   
[零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/description/)   
分析：使用回溯法超时，使用动态规划：dp[i]表示i可以有几种找零方法，动态转移方程：dp[j]+=dp[j-coins[i]]   
代码：
~~~
import java.util.Arrays;

public class So178 {

     //深度搜索，超时
    /*public int change(int amount, int[] coins) {
        Arrays.sort(coins);
        return help(amount,coins,0,0);
    }

    private int help(int amount, int[] coins, int index, int sum) {
        int res=0;
        if(sum==amount){
            return 1;
        }
        if(sum>amount){
            return 0;
        }

        for (int i = index; i <coins.length ; i++) {
            res+=help(amount,coins,i,sum+coins[i]);
        }
        return res;
    }*/
	//动态规划
    public int change(int amount, int[] coins) {
        Arrays.sort(coins);
        int[] dp=new int[amount+1];
        Arrays.sort(coins);
        dp[0]=1;
        for (int i = 0; i <coins.length ; i++) {
            for (int j = coins[i]; j <=amount ; j++) {
                dp[j]+=dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
}
~~~


### 223
题目：给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。    
[连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/description/)  
分析：注意特殊情况，k=0    
方法一：动态规划：O(n^2)   
方法二：一次遍历,证明如下   
代码：
~~~

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class So179 {
    /*public boolean checkSubarraySum(int[] nums, int k) {
	    //dp[i][j]表示从i到j的和
        //dp[i][j]=d[i+1][j]+nums[i]
		//可用一维数组
        int len=nums.length;
        int[] dp=new int[len];
        for (int i = len-1; i >=0 ; i--) {
            dp[i]=nums[i];
            for (int j = len-1; j>i; j--) {
                dp[j]=dp[j]+nums[i];
                if(k==0){
                    if(dp[j]==0){
                        return true;
                    }
                }else if(dp[j]%k==0){
                    return true;
                }
            }
        }
        return false;
    }*/


    /*public boolean checkSubarraySum(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(){{put(0,-1);}};;
        int runningSum = 0;
        for (int i=0;i<nums.length;i++) {
            runningSum += nums[i];
            if (k != 0) runningSum %= k;
            Integer prev = map.get(runningSum);
            if (prev != null) {
                if (i - prev > 1) return true;
            }
            else map.put(runningSum, i);
        }
        return false;
    }*/
	
	
	
    /*
    * 证明：
    * runningSum_j表示从0到nums[j]%k;
    * runningSum_i表示从0到nums[i]%k;
    * 若set中包含了runningSum_j表示从0到nums，则表示
    * (sum_j-sum_i)=n*k
    *
    *
    * */

    public boolean checkSubarraySum(int[] nums, int k) {

        Set<Integer> set=new HashSet<>();
        int runningSum=0,pre=0;
        for (int i = 0; i <nums.length ; i++) {
            runningSum+=nums[i];
            runningSum= 0==k ? runningSum : runningSum%k;
            if(set.contains(runningSum)){
                return true;
            }
            set.add(pre);
            pre=runningSum;
        }
        return false;
    }


}
~~~

### 224
题目：给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。   
[通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/)  
分析：先对数组按照长度降序，字典顺序排序，依次遍历即可   
代码：
~~~
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public class So180 {
    public String findLongestWord(String s, List<String> d) {
        d.sort(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                if(o1.length()==o2.length()){
                   return o1.compareTo(o2);
                }else {
                    return o2.length()-o1.length();
                }
            }
        });

        for(String string : d){
            
            int i=0,j=0;
            char[] cs=string.toCharArray();
            for (;j<cs.length;j++){
                int temp=s.indexOf(cs[j],i);
                if(temp!=-1){
                    i=temp+1;
                }else {
                    break;
                }
            }
            if(j==string.length()){
                return string;
            }
        }
        return "";
    }
}
~~~