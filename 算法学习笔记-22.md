# 算法学习笔记 
### 221
题目：给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。  
[最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/description/)   
分析：注意子序列和子串的区别，动态规划：dp[i][j]是从i到j的回文子序列的长度   
动态转移方程：if(s[i]==s[j]) dp[i][j]=dp[i+1][j-1]+2  else dp[i][j]=max(dp[i][j-1],dp[i+1][j])   
代码：
~~~
public class So177 {
    public int longestPalindromeSubseq(String s) {
        if(s.length()<2){
            return s.length();
        }
        char[] cs=s.toCharArray();
        int len=s.length();
        int[][] dp=new int[len][len];
        for(int i=len-1;i>=0;i--){
            dp[i][i]=1;
            for(int j=i+1;j<len;j++){
                if(cs[i]==cs[j]){
                    dp[i][j]=dp[i+1][j-1]+2;
                }else {
                    dp[i][j]=Math.max(dp[i][j-1],dp[i+1][j]);
                }
            }
        }
        return dp[0][len-1];
    }
}

~~~


### 222
题目：给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

注意: 你可以假设

0 <= amount (总金额) <= 5000  
1 <= coin (硬币面额) <= 5000  
硬币种类不超过500种  
结果符合32位符号整数   
[零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/description/)   
分析：使用回溯法超时，使用动态规划：dp[i]表示i可以有几种找零方法，动态转移方程：dp[j]+=dp[j-coins[i]]   
代码：
~~~
import java.util.Arrays;

public class So178 {

     //深度搜索，超时
    /*public int change(int amount, int[] coins) {
        Arrays.sort(coins);
        return help(amount,coins,0,0);
    }

    private int help(int amount, int[] coins, int index, int sum) {
        int res=0;
        if(sum==amount){
            return 1;
        }
        if(sum>amount){
            return 0;
        }

        for (int i = index; i <coins.length ; i++) {
            res+=help(amount,coins,i,sum+coins[i]);
        }
        return res;
    }*/
	//动态规划
    public int change(int amount, int[] coins) {
        Arrays.sort(coins);
        int[] dp=new int[amount+1];
        Arrays.sort(coins);
        dp[0]=1;
        for (int i = 0; i <coins.length ; i++) {
            for (int j = coins[i]; j <=amount ; j++) {
                dp[j]+=dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
}
~~~