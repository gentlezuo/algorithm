# 算法学习笔记 
### 211
题目：在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。

移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。

注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。   
[机器人能否返回原点](https://leetcode-cn.com/problems/robot-return-to-origin/description/)  
分析：left==right,up==down   
代码：
~~~
class Solution {
    public boolean judgeCircle(String moves) {
        int up=0,left=0;
        for(char c :moves.toCharArray()){
            if(c=='U'){
                up++;
            }else if(c=='D'){
                up--;
            }else if(c=='L'){
                left++;
            }else {
                left--;
            }
        }
        return up==0&&left==0;
    }
}
~~~


### 212
题目：还记得童话《卖火柴的小女孩》吗？现在，你知道小女孩有多少根火柴，请找出一种能使用所有火柴拼成一个正方形的方法。不能折断火柴，可以把火柴连接起来，并且每根火柴都要用到。

输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。  
[火柴拼正方形](https://leetcode-cn.com/problems/matchsticks-to-square/description/)  
分析：dfs，标记法   
代码：
~~~
/*public boolean makesquare(int[] nums) {
        Long sum=0l;
        for(int x:nums){
            sum=sum+x;
        }
        if(sum%4!=0||nums.length<4) return false;
        long width=(sum/4);
        Arrays.sort(nums);
        long sum1=0,sum2=0,sum3=0,sum4=0;
        return helper(nums,nums.length-1,sum1,sum2,sum3,sum4,width);

    }
    public boolean helper(int[] a, int i,long sum1,long sum2,long sum3,long sum4, long width){
        if(sum1>width||sum2>width||sum3>width||sum4>width) return false;
        if(i==-1){
            if(sum1==width&&sum2==width&&sum3==width&&sum4==width) return true;
            else return false;
        }
        return helper(a,i-1,sum1+a[i],sum2,sum3,sum4,width)||
                helper(a,i-1,sum1,sum2+a[i],sum3,sum4,width)||
                helper(a,i-1,sum1,sum2,sum3+a[i],sum4,width)||
                helper(a,i-1,sum1,sum2,sum3,sum4+a[i],width);
    }*/
    public boolean makesquare(int[] nums) {
        int total = 0;
        for (int n : nums) total += n;
        if (total == 0 || total % 4 > 0) return false;
        total /= 4;
        Arrays.sort(nums);
        for (int i = 0; i < 4; i++) {
            if (!search(nums, nums.length - 1, 0, total)) return false;
        }
        return true;
    }

    private boolean search(int[] nums, int start, int sum, int target) {
        if (start < 0 || sum > target) return false;
        for (int i = start; i >= 0; i--) {
            if (nums[i] == 0) continue;
            int temp = nums[i];
            nums[i] = 0;
            if (sum + temp == target || search(nums, i - 1, sum + temp, target)) return true;
            nums[i] = temp;
        }
        return false;
    }
~~~


###213
题目：在计算机界中，我们总是追求用有限的资源获取最大的收益。

现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。

你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。

注意:

给定 0 和 1 的数量都不会超过 100。  
给定字符串数组的长度不会超过 600。   
[一和零](https://leetcode-cn.com/problems/ones-and-zeroes/description/)   
分析：01背包问题   
代码：
~~~
import java.util.Arrays;
import java.util.Comparator;

public class So169 {
    //dp[i][j] 是在m为i,n为j时可以分配的最大数目
    //dp[i][j]=max(dp[i-zero][j-one]+1,dp[i][j])
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp=new int[m+1][n+1];
        int[][] count=new int[strs.length][2];
        Arrays.sort(strs, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.length()-o2.length();
            }
        });
        for(int i=0;i<strs.length;i++){
            String s=strs[i];
            for(char c: s.toCharArray()){
                count[i][c-'0']++;
            }
        }

        for (int i = 0; i <strs.length ; i++) {
            int zero=count[i][0],one=count[i][1];
            for (int j = m; j >=zero ; j--) {
                for (int k = n; k >=one ; k--) {
                    dp[j][k]=Math.max(dp[j][k],dp[j-zero][k-one]+1);
                }
            }
        }
        return dp[m][n];
    }
}
~~~


### 214
题目：两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。

计算一个数组中，任意两个数之间汉明距离的总和。  
[汉明距离总和](https://leetcode-cn.com/problems/total-hamming-distance/description/)  
分析：每个数有32位，按位遍历   
代码：
~~~
public class So170 {
    public int totalHammingDistance(int[] nums) {
        int res=0;
        for (int i = 0; i <32 ; i++) {
            int count=0;
            for (int j = 0; j <nums.length ; j++) {
                if(((nums[j]>>i)&1)==1){
                    count++;
                }
            }
            res+=count*(nums.length-count);
        }
        return res;
    }
}

~~~

### 215
题目：给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 randPoint 。

说明:

输入值和输出值都将是浮点数。   
圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。  
圆周上的点也认为是在圆中。  
randPoint 返回一个包含随机点的x坐标和y坐标的大小为2的数组。  
[在圆内随机生成点](https://leetcode-cn.com/problems/generate-random-point-in-a-circle/description/)  
分析：投掷法，在一个以圆为中心的正方形中投掷  
代码：
~~~
class Solution {
    double r, x, y;
        
    public Solution(double radius, double x_center, double y_center) {
        r = radius;
        x = x_center;
        y = y_center;
    }
    
    public double[] randPoint() {
        Random rand = new Random();
        Double nx = x - r + rand.nextDouble() * 2 * r;
        double ny = y - r + rand.nextDouble() * 2 * r;
        double r2 = r * r;
        while(dis(nx, ny) >= r2){
            nx = x - r + rand.nextDouble() * 2 * r;
            ny = y - r + rand.nextDouble() * 2 * r;
        }
        return new double[]{nx, ny};
    }
    
    // it returns the square of the distance between the point and the center;
    double dis(double nx, double ny){
        return (nx - x) * (nx - x) + (ny - y) * (ny - y);
    }
}
~~~
