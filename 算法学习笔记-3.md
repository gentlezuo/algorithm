### 21
题目：给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。  
[螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/description/)  
分析：旋转即可，注意每次循环不能重复写入上一次的最后一个元素与开头的第一个元素，判断最后行列之中较小的那个数的奇偶  
代码：<pre>public class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res =new ArrayList<>();
        if(matrix.length == 0 || matrix[0].length == 0){
            return res;
        }
        int row=matrix.length;
        int col=matrix[0].length;
        int num=Math.min(col,row)/2;
        for (int i = 0; i <num ; i++) {
            for (int j = i; j <col-i ; j++) {
                res.add(matrix[i][j]);
            }
            for (int j = i; j <row-i-1 ; j++) {
                res.add(matrix[j+1][col-i-1]);
            }
            for (int j = i; j <col-i-1 ; j++) {
                res.add(matrix[row-1-i][col-j-2]);
            }
            for (int j = i; j <row-i-2 ; j++) {
                res.add(matrix[row-2-j][i]);
            }
        }
        if((Math.min(col,row))%2!=0) {
            if (row < col) {
                for (int i = num; i <col-num ; i++) {
                    res.add(matrix[row/2][i]);
                }
            }else {
                for (int i = num; i <row-num ; i++) {
                    res.add(matrix[i][col/2]);
                }
            }
        }
        return res;
    }
}</pre>  

### 22
题目：Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.  
[Jump Game](https://leetcode.com/problems/jump-game/description/)   
分析：双指针，从后往前移动指针，判断nums[left]与right-left的大小，并移动right  
代码：<pre>public class Solution {
    public boolean canJump(int[] nums) {
        int length = nums.length;
        if (length == 1) return true;
        int left = length - 2, rifht = length - 1;
        boolean res = true;
        while (left>=0){
            if(nums[left]>=rifht-left){
                rifht=left;
            }
            left--;
        }
        return rifht==0;
    }
}</pre>
### 23
题目：给出一个区间的集合，请合并所有重叠的区间。  
[合并区间](https://leetcode-cn.com/problems/merge-intervals/description/)  
分析：start<=end，则有重复区间，可以合并，取max(end,end2),否则无重复，重新曲start与end  
代码：<pre>class Solution {
    public List<Interval> merge(List<Interval> intervals) {
        List<Interval> res=new ArrayList<>();
        if(intervals.size()<=1){
            return intervals;
        }else {
            intervals.sort((l,r)->Integer.compare(l.start,r.start));
            int start=intervals.get(0).start;
            int end=intervals.get(0).end;
            for(int i=0;i<intervals.size();i++){
                if(end>=intervals.get(i).start){
                    end=Math.max(end,intervals.get(i).end);
                }else {
                    res.add(new Interval(start,end));
                    start=intervals.get(i).start;
                    end=intervals.get(i).end;
                }
            }
            res.add(new Interval(start,end));
        }
        return res;
    }
}</pre>
### 24
题目：给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。  
[螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/description/)   
从外到内一次循环即可  
代码：<pre>class Solution {
    public int[][] generateMatrix(int n) {
        int count=0;
        int[][] res=new int[n][n];
        for (int i = 0; i <n-i ; i++) {
            for (int j = i; j <n-i ; j++) {
                res[i][j]=++count;
            }
            for (int j = i+1; j <n-i ; j++) {
                res[j][n-1-i]=++count;
            }
            for (int j = i+1; j <n-i ; j++) {
                res[n-i-1][n-1-j]=++count;
            }
            for (int j = i+1; j <n-i-1 ; j++) {
                res[n-j-1][i]=++count;
            }
        }
        return res;
    }
}</pre>
### 25
题目：给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。  
[第k个排列](https://leetcode-cn.com/problems/permutation-sequence/description/)  
分析：通过判断k/(n-i)!与k=k%(n-1)!的值，分别确定每一位的字符，然后删除此字符，只判断其余的字符，k就是剩余n-i个字符的排列的第k个排列，依次遍历减小规模即可。  
注意k==0时k=(n-i)!  
代码:<pre>public String getPermutation(int n, int k) {
        int[] factorial={0,1,2,6,24,120,720,5040,40320,362880};
        List<Integer> num=new LinkedList<>();
        for (int i = 0; i <=n ; i++) {
            num.add(i);
        }
        String res=new String();
        int newK=k;
        for (int i = n; i >1 ; i--) {
            int temp=newK/factorial[i-1];
            newK=newK%factorial[i-1];
            if(newK==0){
                res+=num.get(temp);
                newK=factorial[i-1];
                num.remove(temp);
            }else {
                res+=num.get((temp+1));
                num.remove(temp+1);
            }
        }
        res+=num.get(1);
        return res;
    }</pre>
代码2:<pre>public String getPermutation2(int n, int k) {
        int[] factorial={0,1,2,6,24,120,720,5040,40320,362880};
        StringBuilder sb=new StringBuilder();
        for (int i = 0; i <=n ; i++) {
            sb.append(i);
        }
        StringBuilder res=new StringBuilder();
        int newK=k;
        for (int i = n; i >1 ; i--) {
            int temp=newK/factorial[i-1];
            newK=newK%factorial[i-1];
            if(newK==0){
                res.append(sb.charAt(temp));
                newK=factorial[i-1];
                sb.deleteCharAt(temp);
            }else {
                res.append(sb.charAt(temp+1));
                sb.deleteCharAt(temp+1);
            }
        }
        res.append(sb.charAt(1));
        return res.toString();
    }</pre>
第二个代码比第一个快很多，应该是StringBuilder更快，因为要改变，其有缓冲，比String快，也可能是比LinkenList快。