### 21
题目：给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。  
[螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/description/)  
分析：旋转即可，注意每次循环不能重复写入上一次的最后一个元素与开头的第一个元素，判断最后行列之中较小的那个数的奇偶  
代码：<pre>public class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res =new ArrayList<>();
        if(matrix.length == 0 || matrix[0].length == 0){
            return res;
        }
        int row=matrix.length;
        int col=matrix[0].length;
        int num=Math.min(col,row)/2;
        for (int i = 0; i <num ; i++) {
            for (int j = i; j <col-i ; j++) {
                res.add(matrix[i][j]);
            }
            for (int j = i; j <row-i-1 ; j++) {
                res.add(matrix[j+1][col-i-1]);
            }
            for (int j = i; j <col-i-1 ; j++) {
                res.add(matrix[row-1-i][col-j-2]);
            }
            for (int j = i; j <row-i-2 ; j++) {
                res.add(matrix[row-2-j][i]);
            }
        }
        if((Math.min(col,row))%2!=0) {
            if (row < col) {
                for (int i = num; i <col-num ; i++) {
                    res.add(matrix[row/2][i]);
                }
            }else {
                for (int i = num; i <row-num ; i++) {
                    res.add(matrix[i][col/2]);
                }
            }
        }
        return res;
    }
}</pre>  

### 22
题目：Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.  
[Jump Game](https://leetcode.com/problems/jump-game/description/)   
分析：双指针，从后往前移动指针，判断nums[left]与right-left的大小，并移动right  
代码：<pre>public class Solution {
    public boolean canJump(int[] nums) {
        int length = nums.length;
        if (length == 1) return true;
        int left = length - 2, rifht = length - 1;
        boolean res = true;
        while (left>=0){
            if(nums[left]>=rifht-left){
                rifht=left;
            }
            left--;
        }
        return rifht==0;
    }
}</pre>
### 23
题目：给出一个区间的集合，请合并所有重叠的区间。  
[合并区间](https://leetcode-cn.com/problems/merge-intervals/description/)  
分析：start<=end，则有重复区间，可以合并，取max(end,end2),否则无重复，重新曲start与end  
代码：<pre>class Solution {
    public List<Interval> merge(List<Interval> intervals) {
        List<Interval> res=new ArrayList<>();
        if(intervals.size()<=1){
            return intervals;
        }else {
            intervals.sort((l,r)->Integer.compare(l.start,r.start));
            int start=intervals.get(0).start;
            int end=intervals.get(0).end;
            for(int i=0;i<intervals.size();i++){
                if(end>=intervals.get(i).start){
                    end=Math.max(end,intervals.get(i).end);
                }else {
                    res.add(new Interval(start,end));
                    start=intervals.get(i).start;
                    end=intervals.get(i).end;
                }
            }
            res.add(new Interval(start,end));
        }
        return res;
    }
}</pre>
### 24
题目：给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。  
[螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/description/)   
从外到内一次循环即可  
代码：<pre>class Solution {
    public int[][] generateMatrix(int n) {
        int count=0;
        int[][] res=new int[n][n];
        for (int i = 0; i <n-i ; i++) {
            for (int j = i; j <n-i ; j++) {
                res[i][j]=++count;
            }
            for (int j = i+1; j <n-i ; j++) {
                res[j][n-1-i]=++count;
            }
            for (int j = i+1; j <n-i ; j++) {
                res[n-i-1][n-1-j]=++count;
            }
            for (int j = i+1; j <n-i-1 ; j++) {
                res[n-j-1][i]=++count;
            }
        }
        return res;
    }
}</pre>