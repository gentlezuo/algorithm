# 算法学习笔记
### 101
题目：给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。  
注意：  
num1 和num2 的长度都小于 5100.  
num1 和num2 都只包含数字 0-9.  
num1 和num2 都不包含任何前导零。  
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。  
[字符串相加](https://leetcode-cn.com/problems/add-strings/description/)  
分析：从后往前加，注意进位与两个字符串长度不一致   
代码：
~~~
class Solution {
    public String addStrings(String num1, String num2) {
        int len1=num1.length()-1,len2=num2.length()-1;
        StringBuffer res=new StringBuffer();
        int carry=0;
        while (len1>=0&&len2>=0){
            int sum=  num1.charAt(len1--)-96+ num2.charAt(len2--) +carry;//num1.charAt(len1--)-2*'0'+ num2.charAt(len2--) +carry更好
            carry=sum/10;
            res.append(sum%10);
        }
        while (len1>=0){
            int sum=  num1.charAt(len1--)-48 +carry;
            carry=sum/10;
            res.append(sum%10);
        }
        while (len2>=0){
            int sum=  num2.charAt(len2--)-48 +carry;
            carry=sum/10;
            res.append(sum%10);
        }
        if(carry>0)
            res.append(carry);
        return res.reverse().toString();
    }
}
~~~

### 102
题目：统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。  
请注意，你可以假定字符串里不包括任何不可打印的字符。  
[字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/description/)  
分析：判断是否为空格即可，注意最后判断   
代码：
~~~
class Solution {
    public int countSegments(String s) {
        if(s.equals("")) return 0;
        boolean flag=false;
        int i=0,len=s.length(),res=0;
        while (i<len){
            char c=s.charAt(i++);
            if(c!=' ')
                flag=true;
            else if(flag){
                flag = false;
                ++res;
            }
        }
        if(s.charAt(len-1)!=' ')
            ++res;
        return res;
    }
}
~~~


### 103
题目：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。
字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。  
说明：  
字母异位词指字母相同，但排列不同的字符串。  
不考虑答案输出的顺序。  
[找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/description/)  
分析：使用滑动窗口  
代码：
~~~

public class So83 {
    public List<Integer> findAnagrams(String s, String p) {
        /*
        //错误思路，把字符当成int加起来，再依次减去，符合条件则计入答案，但是a+d=b+c，所以会出错
        List<Integer> res=new ArrayList<>();
        if(s.equals("")||p.length()>s.length()) return res;
        long s_sum=0,sum=0;
        int p_len=p.length(),s_len=s.length();
        for(char c:p.toCharArray())
            sum+=c;
        char[] s_char=s.toCharArray();
        for(int i=0;i<p_len;i++){
            s_sum+=s_char[i];
        }
        int i=0,j=p_len-1;
        while(j<s_len){
            if(s_sum==sum)
                res.add(i);
            if(++j<s_len)
                s_sum=s_sum-s_char[i++]+s_char[j];
        }
        return res;
        */
        //滑动窗口
        
        List<Integer> res=new ArrayList<>();
        if(s.equals("")||p.length()>s.length()) return res;
        int[] chars=new int[26];
        for (char c : p.toCharArray())
            chars[c-'a']++;
        int l=0,r=0,p_len=p.length(),count=p.length();

        while(r<s.length()){
            //count始终大于0
            //只有前后距离为len才移动左边的指针，并且count++
            if(r-l==p_len&&chars[s.charAt(l++)-'a']++>=0)
                count++;
            //当--chars[s.charAt(r++)-'a']<0时，不改变count，也就是如果右边的指针扫过的如果多余了某个字母，并不把该字母计入在count中，随后l在扫描到时只有加上了多余的字符，才会开始计数，抛去了这一段
            if(--chars[s.charAt(r++)-'a']>=0)
                count--;
            if(count==0)
                res.add(l);
        }
        return res;

    }
}
	~~~
### 104
题目：给定一组字符，使用原地算法将其压缩。  
压缩后的长度必须始终小于或等于原数组长度。  
数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。  
在完成原地修改输入数组后，返回数组的新长度。  
[压缩字符串](https://leetcode-cn.com/problems/string-compression/description/)  
分析：一边扫描法  
代码：
~~~
class Solution {
    public int compress(char[] chars) {
        if(chars==null) return 0;
        if(chars.length<2) return chars.length;
        int w=0,i=0,j=0,count=0;
        while(j<chars.length){
            if(chars[i]==chars[j]){
                ++count;
                ++j;
            }
            if(j==chars.length||chars[i]!=chars[j]){
                chars[w++]=chars[i];
                if(count==1){
                    count=0;
                }
                else if(count<10){
                    chars[w++]=(char)(count+'0');
                    count =0; 
                }
                else{
                    String frq=String.valueOf(count);
                    for(char c: frq.toCharArray())
                        chars[w++]=c;
                    count=0;
                }
                i=j;
            }
        }
        return w;
    }
}
~~~


### 105
题目：给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。  
找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。  
[回旋镖的数量](https://leetcode-cn.com/problems/number-of-boomerangs/description/)  
分析：使用map<距离，数量>，res=数量*（数量-1）  
代码：
~~~
class Solution {
    /*
    public int numberOfBoomerangs(int[][] points) {
        int res=0;
        Map<Integer,Integer> map=new HashMap<>();
        for(int i=0;i<points.length;i++){
            for(int j=0;j<points.length;j++){
                if(i==j)
                    continue;
                else{
                    int dis=(points[i][0]-points[j][0])*(points[i][0]-points[j][0])+(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);
                    map.put(dis, map.getOrDefault(dis, 0) + 1);
                }
            }
            for(int dis :map.values())
                res+=(dis*(dis-1));
            map.clear();
        }
        return res;
    }
｝
~~~

### 106
题目：给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。  
找到所有在 [1, n] 范围之间没有出现在数组中的数字。  
您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。  
[找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/description/)  
分析：两种方法：  
第一：原地交换，空间少   
第二：申请一个数组，标记法，时间少   
代码：
~~~
class Solution {
    //排序法
    /*public List<Integer> findDisappearedNumbers(int[] nums) {
        int i=0,write=0;
        List<Integer> res=new ArrayList<Integer>();
        while(i<nums.length){
		//i位置是i-1或者nums[i]-1位置是nums[i]则跳过
            if(nums[i]!=i+1&&nums[nums[i]-1]!=nums[i])
                swap(nums,nums[i]-1,i);
            else ++i;
        }
        i=0;
        while(i<nums.length){
            if(nums[i]!=i+1)
                res.add(i+1);
            ++i;
        }
        return res;
    }
    public void swap(int[] nums,int i,int j){
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }
    */
	//标记法
    public List<Integer> findDisappearedNumbers(int[] nums) {
        List<Integer> res=new ArrayList<Integer>();
        int[] temp=new int[nums.length];
        for(int i:nums) temp[i-1]=-1;
        for(int i=0;i<nums.length;i++){
            if(temp[i]!=-1)
                res.add(i+1);
        }
        return res;
    }
}
~~~
### 107
题目：给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。  
[最小移动次数使数组元素相等](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/description/)  
分析：使sum=每个数之和，移动n次，最后每个数变成了min+k,SUM=len*(min+k)=sum+k*(len-1)==> k=sum-min*len;，也可以理解为每次-1   
代码：
~~~
class Solution {
    //len*(min+k)=sum+k*(len-1).
    //==> k=sum-min*len;
    public int minMoves(int[] nums) {
      int res=0,min=nums[0];
        for(int num:nums) min=Math.min(min,num);
        for(int num:nums) res+=(num-min);
        return res;
    }
}
~~~

