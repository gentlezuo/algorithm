# 算法学习笔记

### 91
题目：给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)  
[赎金信](https://leetcode-cn.com/problems/ransom-note/description/)  
分析：mangazine中的该字母的个数大于等于ransom中的该字母的个数即可  
代码：
~~~
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int len1=ransomNote.length(),len2=magazine.length();
        int[] nums=new int[26];
        for(int i=0;i<len2;i++){
            nums[magazine.charAt(i)-'a']+=1;
        }
        for(int i=0;i<len1;i++){
            if((--nums[ransomNote.charAt(i)-'a'])<0)
                return false;
        }
        return true;
    }
}
~~~

### 92
题目：给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。  
[字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/description/)  
分析：可以从后往前遍历，如果不重复就添加入列表的首端，最后获取列表首端的字符的索引  
方法二：若字符出现一次，则firstindex==lastindex，可以从a循环到z，选取较小的那一个字符的索引  
代码：
~~~

public class So {
    /*public int firstUniqChar(String s) {
        int[] nums=new int[26];
        LinkedList<Character> list=new LinkedList<>();
        for(int i=s.length()-1;i>=0;i--){
            char c=s.charAt(i);
            if(nums[c-'a']==0){
                nums[c-'a']=1;
                list.addFirst(c);
            }else
                remove(list,c);
        }
        return list.isEmpty() ? -1 : s.indexOf(list.get(0));
    }
    private void remove(LinkedList<Character> list,char c){
        for(int i=0;i<list.size();i++){
            if(list.get(i)==c)
                list.remove(i);
        }
    }*/
    public int firstUniqChar(String s) {
        int res=-1;
        for (char i='a';i<='z';i++){
            int firstIndex=s.indexOf(i);
            if(firstIndex!=-1&&firstIndex==s.lastIndexOf(i))
                res = res== -1 ? firstIndex : Math.min(firstIndex,res);
        }
        return res;
    }
}
~~~

### 93
题目：给定一个字符串，请将字符串里的字符按照出现的频率降序排列。  
[根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/description/)  
分析：两种方法都是求出每个字符出现的次数，按长度排序   
代码：
~~~

public class So {
    /*public String frequencySort(String s) {
        Map<Character,Integer> map=new TreeMap<>() ;
        StringBuffer res =new StringBuffer();
        for (int i = 0; i <256 ; i++) {
            map.put((char) i,0);
        }
        for (int i = 0; i <s.length() ; i++) {
            char c=s.charAt(i);
            map.put(c,map.get(c)+1);
        }
        List<Map.Entry<Character,Integer>> list = new ArrayList<Map.Entry<Character,Integer>>(map.entrySet());
        Collections.sort(list, new Comparator<Map.Entry<Character, Integer>>() {
            @Override
            public int compare(Map.Entry<Character, Integer> o1, Map.Entry<Character, Integer> o2) {
                return o2.getValue().compareTo(o1.getValue());
            }
        });
        for (Map.Entry<Character,Integer> mapping:list){
            for (int i=0;i<mapping.getValue();i++){
                res.append(mapping.getKey());
            }
        }
        return res.toString();
    }*/
    public String frequencySort(String s) {
        char[] chars=s.toCharArray();
        List<String> list=new ArrayList<>();
        Arrays.sort(chars);
        String temp=new String(chars);
        int index=0;
        while (index<chars.length){
            char c=chars[index];
            int len=temp.lastIndexOf(c)+1;
            list.add(temp.substring(index,len));
            index=len;
        }
        list.sort((o1, o2) -> o2.length()-o1.length());
        StringBuilder sb = new StringBuilder();
        for (String string : list) {
            sb.append(string);
        }
        return sb.toString();
    }
}
~~~

### 94
题目：给定一个非空的整数数组，返回其中出现频率前 k 高的元素。  
[前K个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/description/)  
分析:和上一题一样,排序，或者使用桶排序线性时间   
代码：
~~~
public class So77 {
    /*public List<Integer> topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map=new TreeMap<>();
        List<Integer> res=new ArrayList<>(k);
        for (int a:nums){
            if(!map.containsKey(a))
                map.put(a,1);
            else
                map.put(a,map.get(a)+1);
        }
        List<Map.Entry<Integer,Integer>> list = new ArrayList<Map.Entry<Integer,Integer>>(map.entrySet());
        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer>>() {
            @Override
            public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {
                return o2.getValue()-o1.getValue();
            }
        });
        for (int i = 0; i <k ; i++) {
            res.add(list.get(i).getKey());
        }
        return res;
    }*/
    public List<Integer> topKFrequent(int[] nums, int k) {
        List<Integer>[] bucket=new ArrayList[nums.length+1];
        Map<Integer,Integer> map=new TreeMap<>();
        List<Integer> res=new ArrayList<>(k);
        //map(数字：出现的次数)
        for (int a:nums) {
            map.put(a, map.getOrDefault(a, 0) + 1);
        }
        //bucket[出现的次数]={出现该次数的数字的集合}
        for (int key :map.keySet()){
            int count=map.get(key);
            if(bucket[count]==null)
                bucket[count]=new ArrayList<>();
            bucket[count].add(key);
        }
        for (int i=bucket.length-1;i>=0;i--){
            if(bucket[i]!=null){
                for(int a: bucket[i]){
                    if(res.size()<k)
                        res.add(a);
                }
            }
        }
        return res;
    }

~~~

### 95
题目：
给定两个字符串 s 和 t，它们只包含小写字母。   
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。  
请找出在 t 中被添加的字母。  
[找不同](https://leetcode-cn.com/problems/find-the-difference/description/)  
分析：一种方法，相加再相减，剩下的是多余的  
第二种方法：多余的一定是奇数，其余为偶数，异或所有的字符，剩余者即是  
代码：
~~~
class Solution {
    public char findTheDifference(String s, String t) {
	//one
        /*int sum=0;
        char[] s_chars=s.toCharArray();
        char[] t_chars=t.toCharArray();
        for(char c : t_chars)
            sum+=c;
        for(char c : s_chars)
            sum-=c;
        return (char)sum;
        */
		//two
        char[] s_chars=s.toCharArray();
        char[] t_chars=t.toCharArray();
        int res=0;
        for(char c : t_chars)
            res=res^c;
        for(char c : s_chars)
            res=res^c;
        return (char)res;
    }
}
~~~

### 96
题目：在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...中找到第 n 个数字。  
注意:  
n 是正数且在32为整形范围内 ( n < 231)。   
[第N个数字](https://leetcode-cn.com/problems/nth-digit/description/)  
分析：[借用](https://leetcode.com/problems/nth-digit/discuss/88369/0ms-C++-Solution-with-Detail-Explanation)
为了使问题更容易，我将问题分为三个部分：

- 计算该数字的位数。
- 计算数字是多少。
- 找出我们想要的数字中的哪个数字。
- 你可以找到在相对码部分代码段。
这是一个帮助您理解我的代码的示例：

例：

- 输入：250
- 在步骤1之后，您会发现第250个数字必须属于3位数字，因为1~9只能提供9位数字，10~99只能提供180位数字。这里，n= 250-9-90 * 2 = 61，并且digits= 3。
- 在第2步中，我们将找到目标号码，number在我的代码中命名。从步骤1开始，n变为61，这意味着“3位数字中的第61位是我们正在寻找的数字”。很容易，我们知道3位数的第61位属于number= 100 + 61/3 = 100 + 20 = 120. index是目标数字的索引number。如果index等于0，则表示目标数字是最后一位数number。
步骤3，从步骤2开始，我们知道index= n％digits= 61％3 = 1，这意味着目标数字是第1位数number。然后，回来1。


代码：
~~~
class Solution {
    public int findNthDigit(int n) {
        //可能溢出90000....大于了integer.max(214....)
        long base=9;
        //求位数，依次减去9，90，900...
        int wei=1;
            while(n>wei*base){
                n-=base*wei;
                ++wei;
                base*=10;
            }
        //求索引，即在数的第几位
        int index=n%wei;
        //余数为0，即为除数
        if(index==0) index=wei;
        //求该数,如果有3位，则是100+(n/位数)，如果余数为0，则需要减去一，因为把0变为位数，取不到下一位而是上一位的最后一位，反之取下一位位数，多余的下一步/除去即可。
        long num=(index==wei)?(int)Math.pow(10,wei-1)+n/wei-1:(int)Math.pow(10,wei-1)+n/wei;
        for(int i=index;i<wei;i++){
            num/=10;
        }
        return (int)num%10;
    }
}
~~~