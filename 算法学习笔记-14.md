# 算法学习笔记 
### 141
题目：根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。  

给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；  
如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；  
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；  
如果死细胞周围正好有三个活细胞，则该位置死细胞复活；  
根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。   
[生命游戏](https://leetcode-cn.com/problems/game-of-life/description/)  
分析：使用标记法  
代码：
~~~
public class So {
    public void gameOfLife(int[][] board) {
        if(board==null||board.length==0||board[0].length==0){
            return;
        }
        int m=board.length,n=board[0].length;
        for (int i = 0; i <m ; i++) {
            for (int j = 0; j <n ; j++) {
                int count=check(board,i,j,m-1,n-1);
                if(board[i][j]==1&&(count<2||count>3)){
				//记录下来此处下一次应该变为0，3的二进制位11，不影响&1运算
                    board[i][j]=3;
				//记录下来此处下一次应该变为1，4的二进制位100，不影响&1运算
                }else if(board[i][j]==0&&count==3){
                    board[i][j]=4;
                }
            }
        }
        for (int i = 0; i <m ; i++) {
            for (int j = 0; j <n ; j++) {
                if(board[i][j]==3){
                    board[i][j]=0;
                }else if(board[i][j]==4){
                    board[i][j]=1;
                }
            }
        }
    }


    private int check(int[][] boards,int row,int col,int m,int n){
        int oneCount=0;
		//使用=Math.max(0,row-1)，Math.min(m,row+1)避免越界 
        for(int i=Math.max(0,row-1);i<=Math.min(m,row+1);i++){
            for (int j = Math.max(0,col-1); j <=Math.min(n,col+1) ; j++) {
                oneCount+=(1&boards[i][j]);
            }
        }
        oneCount-=(boards[row][col]);
        return oneCount;

    }
}
~~~

### 142
题目：你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。
请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。   
请注意秘密数字和朋友的猜测数都可能含有重复数字。    
[猜数字](https://leetcode-cn.com/problems/bulls-and-cows/description/)  
分析：遍历判断即可   
代码：
~~~
class Solution {
    public String getHint(String secret, String guess) {
        int[] numberSecret=new int[10];
        int[] numberGuess=new int[10];
        char[] sc=secret.toCharArray();
        char[] gu=guess.toCharArray();
        int bull=0,cow=0;
        for(int i=0;i<secret.length();i++){
            if(sc[i]==gu[i]){
                ++bull;
            }
            numberSecret[sc[i]-'0']+=1;
            numberGuess[gu[i]-'0']+=1;
        }
        for (int i=0;i<10;i++){
            cow+=Math.min(numberGuess[i],numberSecret[i]);
        }
        cow-=bull;
        return bull+"A"+cow+"B";
    }
}
~~~

### 143
题目：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。   
[零钱兑换](https://leetcode-cn.com/problems/coin-change/description/)   
分析：动态规划dp[i]=min(dp[i],dp[i-coin]+1) coin in coins ，**第二个类交换了内外循环，减少了判断**   
代码：
~~~
/*class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount==0) return 0;
        int[] dp=new int[amount+1];
        Arrays.fill(dp,Integer.MAX_VALUE);
        Arrays.sort(coins);
        for (int i = 1; i <=amount ; i++) {
            for (int j=0;j<coins.length;j++){
                int temp=i-coins[j];
                if(temp<0)
                    break;
                if(temp==0){
                    dp[i]=1;
                    break;
                }
                if(temp>0&&dp[temp]!=Integer.MAX_VALUE){
                    dp[i]=Math.min(dp[temp]+1,dp[i]);
                }
                
            }
        }

        return dp[amount]==Integer.MAX_VALUE ?-1 :dp[amount];
    }
}
*/
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp=new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0]=0;
        for (int coin : coins) {
            for (int i = coin; i <=amount ; i++) {
                dp[i]=Math.min(dp[i],dp[i-coin]+1);
            }
        }

        return dp[amount]==amount+1 ? -1 :dp[amount];
    }
}
~~~ 
