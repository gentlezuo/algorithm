# 算法学习笔记 
### 141
题目：根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。  

给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；  
如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；  
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；  
如果死细胞周围正好有三个活细胞，则该位置死细胞复活；  
根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。   
[生命游戏](https://leetcode-cn.com/problems/game-of-life/description/)  
分析：使用标记法  
代码：
~~~
public class So {
    public void gameOfLife(int[][] board) {
        if(board==null||board.length==0||board[0].length==0){
            return;
        }
        int m=board.length,n=board[0].length;
        for (int i = 0; i <m ; i++) {
            for (int j = 0; j <n ; j++) {
                int count=check(board,i,j,m-1,n-1);
                if(board[i][j]==1&&(count<2||count>3)){
				//记录下来此处下一次应该变为0，3的二进制位11，不影响&1运算
                    board[i][j]=3;
				//记录下来此处下一次应该变为1，4的二进制位100，不影响&1运算
                }else if(board[i][j]==0&&count==3){
                    board[i][j]=4;
                }
            }
        }
        for (int i = 0; i <m ; i++) {
            for (int j = 0; j <n ; j++) {
                if(board[i][j]==3){
                    board[i][j]=0;
                }else if(board[i][j]==4){
                    board[i][j]=1;
                }
            }
        }
    }


    private int check(int[][] boards,int row,int col,int m,int n){
        int oneCount=0;
		//使用=Math.max(0,row-1)，Math.min(m,row+1)避免越界 
        for(int i=Math.max(0,row-1);i<=Math.min(m,row+1);i++){
            for (int j = Math.max(0,col-1); j <=Math.min(n,col+1) ; j++) {
                oneCount+=(1&boards[i][j]);
            }
        }
        oneCount-=(boards[row][col]);
        return oneCount;

    }
}
~~~

### 142
题目：你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。
请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。   
请注意秘密数字和朋友的猜测数都可能含有重复数字。    
[猜数字](https://leetcode-cn.com/problems/bulls-and-cows/description/)  
分析：遍历判断即可   
代码：
~~~
class Solution {
    public String getHint(String secret, String guess) {
        int[] numberSecret=new int[10];
        int[] numberGuess=new int[10];
        char[] sc=secret.toCharArray();
        char[] gu=guess.toCharArray();
        int bull=0,cow=0;
        for(int i=0;i<secret.length();i++){
            if(sc[i]==gu[i]){
                ++bull;
            }
            numberSecret[sc[i]-'0']+=1;
            numberGuess[gu[i]-'0']+=1;
        }
        for (int i=0;i<10;i++){
            cow+=Math.min(numberGuess[i],numberSecret[i]);
        }
        cow-=bull;
        return bull+"A"+cow+"B";
    }
}
~~~

### 143
题目：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。   
[零钱兑换](https://leetcode-cn.com/problems/coin-change/description/)   
分析：动态规划dp[i]=min(dp[i],dp[i-coin]+1) coin in coins ，**第二个类交换了内外循环，减少了判断**   
代码：
~~~
/*class Solution {
    public int coinChange(int[] coins, int amount) {
        if(amount==0) return 0;
        int[] dp=new int[amount+1];
        Arrays.fill(dp,Integer.MAX_VALUE);
        Arrays.sort(coins);
        for (int i = 1; i <=amount ; i++) {
            for (int j=0;j<coins.length;j++){
                int temp=i-coins[j];
                if(temp<0)
                    break;
                if(temp==0){
                    dp[i]=1;
                    break;
                }
                if(temp>0&&dp[temp]!=Integer.MAX_VALUE){
                    dp[i]=Math.min(dp[temp]+1,dp[i]);
                }
                
            }
        }

        return dp[amount]==Integer.MAX_VALUE ?-1 :dp[amount];
    }
}
*/
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp=new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0]=0;
        for (int coin : coins) {
            for (int i = coin; i <=amount ; i++) {
                dp[i]=Math.min(dp[i],dp[i-coin]+1);
            }
        }

        return dp[amount]==amount+1 ? -1 :dp[amount];
    }
}
~~~ 

### 144
题目：给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 出发。  

说明:

如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前   
所有的机场都用三个大写字母表示（机场代码）。  
假定所有机票至少存在一种合理的行程。   
[重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/description/)   
分析；dfs  
代码：
~~~

public class So {
//记下每一个行不通的路作为结尾  
    /*public List<String> findItinerary(String[][] tickets) {
        Map<String,PriorityQueue<String>> map=new HashMap<>();
        for (String[] ticket: tickets)  {
            if(!map.containsKey(ticket[0])){
                map.put(ticket[0],new PriorityQueue<>());
            }
            map.get(ticket[0]).add(ticket[1]);
        }
        List<String> res=new ArrayList<>();
        Stack<String> stack=new Stack<>();
        stack.push("JFK");
        while (!stack.isEmpty()){
            while (map.containsKey(stack.peek())&&!map.get(stack.peek()).isEmpty()){
                stack.push(map.get(stack.peek()).poll());
            }
            res.add(0,stack.pop());
        }
        return res;
    }
    */
    public List<String> findItinerary(String[][] tickets) {
        Map<String,ArrayList<String>> map=new HashMap<>();
        for (String[] ticket: tickets)  {
            if(!map.containsKey(ticket[0])){
                map.put(ticket[0],new ArrayList<String>());
            }
            map.get(ticket[0]).add(ticket[1]);
            map.get(ticket[0]).sort(String::compareTo);
        }

        List<String> ans = new ArrayList<>();
        ans.add("JFK");
        dfs(ans, tickets.length+1, "JFK", map);
        return ans;
    }

    private boolean dfs(List<String> ans, int count, String s,  Map<String,ArrayList<String>> map){
        if (ans.size()==count)
            return true;
        List<String> list = map.get(s);
        if (list==null)
            return false;
        for (int i=0; i<list.size(); i++){
            String tmp=list.get(i);
            ans.add(tmp);
            list.remove(i);
            if (dfs(ans, count, tmp, map))
                return true;
            ans.remove(ans.size()-1);
            list.add(i,tmp);
        }
        return false;
    }
}
~~~

### 145
题目：给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。  

数学表达式如下:  
如果存在这样的 i, j, k,  且满足 0 ≤ i < j < k ≤ n-1，  
使得 arr[i] < arr[j] < arr[k] ，返回 true ; 否则返回 false 。   
[递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/description/)   
分析：使用两个变量，遍历该数组，如果大于第一个数，就赋值给第二个数，如果大于第一第二个数，就证明存在。当然如果小于第一或者第二，就将其赋予给它   
代码：
~~~
class Solution {
    public boolean increasingTriplet(int[] nums) {
        int one=Integer.MAX_VALUE;
        int two=Integer.MAX_VALUE;
        for(int curr:nums){
            if(curr<=one){
                one=curr;
            }else if(curr<=two){
                two=curr;
            }else{
                return true;
            }
        }
        return false;
    }
}
~~~

### 146
题目：给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。   
[比特位计数](https://leetcode-cn.com/problems/counting-bits/description/)  
分析：  
方法一：遍历每个数，使用与运算获取1的个数   
方法二：动态规划：数字i的1的个数一定是将i的二进制的末尾的0去掉再减一的数的1的个数的加1：例如res[111001000]=res[111000]+1   
方法三：动态规划：res[10011100]=res[10011000]+1
代码：
~~~
import java.util.Arrays;

public class So {
    /*public int[] countBits(int num) {
        int[] res=new int[num+1];
        for(int i=0;i<=num;i++){
            res[i]=numberOf1(i);
        }
        return res;
    }
    public int numberOf1(int n){
        int count = 0;
        while(n!=0){
            n = n&(n-1);
            count++;
        }
        return count;
    }
    */
    //动态规划1
    public int[] countBits(int num) {
        int[] res=new int[num+1];
        for (int i=1;i<=num;i++){
            int temp=i;
            while ((temp&1)==0){
                temp>>=1;
            }
            res[i]=res[temp-1]+1;
        }
        return res;
    }
    public static void main(String[] args){
        System.out.println(Arrays.toString(new S0100().countBits(4)));
    }
	//动态规划2
	/*public int[] countBits(int num) {
        int[] res=new int[num+1];
        for (int i=1;i<=num;i++){
            res[i]=res[i&(i-1)]+1;
        }
        return res;
    }
	*/
}

~~~