# 算法学习笔记 
### 231
题目：给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。   
[01 矩阵](https://leetcode-cn.com/problems/01-matrix/description/)   
分析：从零开始向外移动，bfs
代码：
~~~
import java.util.LinkedList;
import java.util.Queue;

public class So187 {
    public int[][] updateMatrix(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    queue.offer(new int[] {i, j});
                }
                else {
                    matrix[i][j] = Integer.MAX_VALUE;
                }
            }
        }

        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            for (int[] d : dirs) {
                int r = cell[0] + d[0];
                int c = cell[1] + d[1];
                if (r < 0 || r >= m || c < 0 || c >= n || matrix[r][c] <= matrix[cell[0]][cell[1]] + 1) {
                    continue;
                }
                queue.add(new int[] {r, c});
                matrix[r][c] = matrix[cell[0]][cell[1]] + 1;
            }
        }

        return matrix;
    }
}
~~~

### 232
题目：班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。   
[ 朋友圈](https://leetcode-cn.com/problems/friend-circles/description/)  
分析：使用dfs，并且记住哪一行已经遍历过   
代码：
~~~
public class So188 {
    public int findCircleNum(int[][] M) {
        int res = 0;
        boolean[] visited=new boolean[M.length];
        for (int i = 0; i < M[0].length; i++) {
            if (!visited[i]) {
                res++;
                help(M, i,visited);
            }
        }
        return res;
    }

    private void help(int[][] m, int i,boolean[] visited) {
        visited[i]=true;
        for (int k = 0; k <m.length ; k++) {
            if(m[i][k]==1&&!visited[k]){
                help(m, k,visited);
            }
        }
    }
}
~~~


### 233
题目：给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -> 2 / 3 / 4 。

但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。    
[最优除法](https://leetcode-cn.com/problems/optimal-division/description/)  
分析：第一个数一定是被除数，要使除数更小才能是结果更大，所以是接下来所有的数应该相除    
代码：
~~~
class Solution {
    public String optimalDivision(int[] nums) {
        if(nums.length==1){
            return nums[0]+"";
        }
        if(nums.length==2){
            return nums[0]+"/"+nums[1];
        }
        StringBuffer sb=new StringBuffer();
        sb.append(nums[0]).append("/").append("(").append(nums[1]);
        for(int i=2;i<nums.length;i++){
            sb.append("/").append(nums[i]);
        }
        sb.append(")");
        return sb.toString();
        
    }
}
~~~