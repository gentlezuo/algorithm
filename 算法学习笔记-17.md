# 算法学习笔记 
### 171
题目：给定一个非空字符串，其中包含字母顺序打乱的英文单词表示的数字0-9。按升序输出原始的数字。  
注意:  
输入只包含小写英文字母。  
输入保证合法并可以转换为原始的数字，这意味着像 "abc" 或 "zerone" 的输入是不允许的。  
输入字符串的长度小于 50,000。   
[从英文中重建数字](https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/description/)   
分析：根据数字0，8，4，6，3，2，1，5，7，9和字母z,g,u,x,h,t,o,f,s,e可以确定该数字的个数；每次需要更新所涉及的字母的数字，即减去该数字包含每个字母的数量     
代码：
~~~
public class So {
    public String originalDigits(String s) {
        StringBuilder sb=new StringBuilder();
        int[] countOfchar=new int[26];
        int[] countOfNum=new int[10];
        for (char c:s.toCharArray()){
            countOfchar[c-'a']++;
        }
        int curr=0;
        //0
        curr=countOfchar['z'-'a'];
        countOfNum[0]=curr;
        for(char c:"zero".toCharArray()){
            countOfchar[c-'a']-=curr;
        }
        //8
        curr=countOfchar['g'-'a'];
        for(char c:"eight".toCharArray()){
            countOfchar[c-'a']-=curr;
        }
        countOfNum[8]=curr;
        //4
        curr=countOfchar['u'-'a'];
        for(char c:"four".toCharArray()){
            countOfchar[c-'a']-=curr;
        }
        countOfNum[4]=curr;
        //6
        curr=countOfchar['x'-'a'];
        for(char c:"six".toCharArray()){
            countOfchar[c-'a']-=curr;
        }
        countOfNum[6]=curr;
        //3
        curr=countOfchar['h'-'a'];
        for(char c:"three".toCharArray()){
            countOfchar[c-'a']-=curr;
        }
        countOfNum[3]=curr;
        //2
        curr=countOfchar['t'-'a'];
        for(char c:"two".toCharArray()){
            countOfchar[c-'a']-=curr;
        }
        countOfNum[2]=curr;
        //1
        curr=countOfchar['o'-'a'];
        for(char c:"one".toCharArray()){
            countOfchar[c-'a']-=curr;
        }
        countOfNum[1]=curr;
        //5
        curr=countOfchar['f'-'a'];
        for(char c:"five".toCharArray()){
            countOfchar[c-'a']-=curr;
        }
        countOfNum[5]=curr;
        //7
        curr=countOfchar['s'-'a'];
        for(char c:"seven".toCharArray()){
            countOfchar[c-'a']-=curr;
        }
        countOfNum[7]=curr;
        //9
        curr=countOfchar['e'-'a'];
        for(char c:"nine".toCharArray()){
            countOfchar[c-'a']-=curr;
        }
        countOfNum[9]=curr;
        for (int i = 0; i <10 ; i++) {
            for (int j = 0; j <countOfNum[i] ; j++) {
                sb.append(String.valueOf(i));
            }
        }
        return sb.toString();
    }
}

~~~

### 172
题目：给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。    
[替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/description/)  
分析：使用类似滑动窗口的方法   
代码：
~~~
public class So127 {
    /*public int characterReplacement(String s, int k) {
        char[] cs=s.toCharArray();
        int res=0;
        for (char c ='A' ; c <='Z' ; c++) {
            int first=0,max=0,count=k;
            for (int j = 0; j <cs.length ; j++) {
                if(cs[j]==c){
                    ++max;
                }else if(cs[j]!=c&&count==0){
                    while (first<j&&cs[first++]==c){
                        max--;
                    }
                }else if(cs[j]!=c&&count>0){
                    ++max;
                    --count;
                }
                res=Math.max(res,max);
            }
        }
        return res;
    }*/

    public int characterReplacement(String s, int k) {
        int left = 0, right = 0;
        int[] hash = new int[26];
        int maxOccur = 0;
        int maxLen = 0;

        while (right < s.length()) {
            hash[s.charAt(right)-'A']++;
            maxOccur = Math.max(maxOccur, hash[s.charAt(right)-'A']);

            if (right+1 - left - maxOccur <= k) {
                maxLen = Math.max(maxLen, right+1 - left);
            }
            if (right+1 - left - maxOccur > k) hash[s.charAt(left++)-'A']--;
            right++;
        }
        return maxLen;
    }
}

~~~

### 173
题目：一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 "A", "C", "G", "T"中的任意一个。

假设我们要调查一个基因序列的变化。一次基因变化意味着这个基因序列中的一个字符发生了变化。

例如，基因序列由"AACCGGTT" 变化至 "AACCGGTA" 即发生了一次基因变化。

与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。

现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。

注意:

起始基因序列默认是合法的，但是它并不一定会出现在基因库中。  
所有的目标基因序列必须是合法的。  
假定起始基因序列与目标基因序列是不一样的。  
[最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/description/)   
分析：可以使用bfs，也可以回溯   
代码：
~~~

public class So128 {
    /*public int minMutation(String start, String end, String[] bank) {
        int res=0;
        Set<String> bankSet = new HashSet<>(Arrays.asList(bank));
        Set<String> visited=new HashSet<>();
        Queue<String> queue=new ArrayDeque<>();
        visited.add(start);
        queue.add(start);
        char[] cs=new char[]{'T','C','A','G'};
        while (!queue.isEmpty()){
            int size=queue.size();
            while (size-->0){
                String curr=((ArrayDeque<String>) queue).pop();
                if(curr.equals(end)){
                    return res;
                }
                char[] currChars=curr.toCharArray();
                for (int i = 0; i <currChars.length ; i++) {
                    char old=currChars[i];
                    for (char c:cs){
                        currChars[i]=c;
                        String temp=new String(currChars);
                        if(bankSet.contains(temp)&&!visited.contains(temp)){
                            visited.add(temp);
                            queue.add(temp);
                        }
                    }
                    currChars[i]=old;
                }
            }
            res++;
        }
        return -1;
    }*/
	//回溯法
    public int minMutation(String start, String end, String[] bank) {
        boolean[] isVisited = new boolean[bank.length];
        fun(start, end, bank, isVisited, 0);
        return sum;
    }

    int sum = -1;

    private void fun(String start, String end, String[] bank, boolean[] isVisited, int num) {
        for (int i = 0; i < isVisited.length; i++) {
            if (!isVisited[i] && helper(start, bank[i])) { // 找到下一个未访问的且可达的字符串
                if (end.equals(bank[i])) {
                    sum = (sum == -1) ? (num + 1) : Math.min(sum, num + 1);
                } else {
                    isVisited[i] = true;
                    fun(bank[i], end, bank, isVisited, num + 1);
                    isVisited[i] = false;
                }
            }
        }
    }

    /**
     * 用于判断两个字符串是否只相差一个字符
     */
    public boolean helper(String from, String to) {
        int num = 0;
        for (int n = 0; n < 8; n++) {
            if (from.charAt(n) != to.charAt(n))
                num += 1;
        }
        return num == 1;
    }
}
~~~


### 174
题目：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。  
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。   
[无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/description/)   
分析：贪心，按照start升序排序，若start相等，以end降序排序，贪end较小的   
代码：
~~~
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class So129 {
    //greed
    public int eraseOverlapIntervals(Interval[] intervals) {
        if(intervals.length<2){
            return 0;
        }
        int res=0;
        //按照start升序排序，若start相等，以end降序排序
        Arrays.sort(intervals, new Comparator<Interval>() {
            @Override
            public int compare(Interval o1, Interval o2) {
                if(o1.start-o2.start==0){
                    return o2.end-o1.end;
                }
                return o1.start-o2.start;
            }
        });
        //双指针
        int i=0,j=1;
        while (j < intervals.length) {
            //start相等，由于是end降序，贪end较小的
            if(intervals[i].start==intervals[j].start){
                res++;
                i++;
            } else if(intervals[i].end>intervals[j].start){
                //贪end较小的
                if(intervals[i].end>intervals[j].end){
                    i=j;
                    res++;
                }else {
                    res++;
                }
            }else {
                i=j;
            }
            j++;
        }
        return res;
    }
}
~~~


