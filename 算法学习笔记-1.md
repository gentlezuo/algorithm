# 算法学习笔记(刷leetcode笔记)  

### 1
题目：给定一个字符串，找出不含有重复字符的最长子串的长度。    
[https://leetcode-cn.com/problems/add-two-numbers/description/](https://leetcode-cn.com/problems/add-two-numbers/description/ "链接")  
分析：  
* 暴力法，时间复杂度太大  
* 采用滑动窗口方法,用map标记  
<pre>
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int res=0;
        int length=s.length();
        Map<Character,Integer> map=new HashMap<>();
        for(int i=0,j=0;j< length;j++){
            if(map.containsKey(s.charAt(j))){
                i=Math.max(i,map.get(s.charAt(j))+1);
            }
            map.put(s.charAt(j), j);
            res=Math.max(res,j-i+1);
        }
        return res;
    }
}
</pre>

### 2
题目：给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。  
你可以假设除了数字 0 之外，这两个数字都不会以零开头。  
[https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/)   
分析：  
遍历两个链表即可
- 注意链表可能不一样长
- 每一位可能会进位0或1
- 注意遍历完后还可能有一位进位
<pre> /**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int jinwei=0;
        ListNode result=new ListNode(0);
        ListNode res=result;
        while(l1!=null || l2!=null){
            int a= (l1==null) ? 0 : l1.val;
            int b= (l2==null) ? 0 : l2.val;
            if(l1!=null){
                l1=l1.next;
            }
            if(l2!=null){
                l2=l2.next;
            }
            int temp=a+b+jinwei;
            jinwei=temp/10;
            res.next= new ListNode(temp%10);
            res=res.next;
        }
        if(jinwei>0){//判断最后一位进位
            res.next=new ListNode(jinwei);
        }
        return result.next;
    }
}</pre>

### 3
题目：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。   
[https://leetcode-cn.com/problems/longest-palindromic-substring/description/](https://leetcode-cn.com/problems/longest-palindromic-substring/description/)   
分析：从每一个字符开始，从中间到两边扩展,选择最长的substring
<pre>class Solution {
    public String longestPalindrome(String s) {
        String res="";
        int length=0;
        for(int i=0;i< s.length();i++){
            int a=expend(s,i,i);
            int b=expend(s,i,i+1);
            int temp=Math.max(a,b);
            if(length< temp){
                length=temp;
                res=s.substring(i-(length-1)/2,i+length/2+1);
            }
        }
        return res;
    }
    
    
    public int expend(String s,int left,int right){//return length
        while(left>=0 && right< s.length() && s.charAt(left)==s.charAt(right)){
            left--;
            right++;
        }
        return right-left-1;
    }
}</pre>
### 4
题目：给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。  
说明：你不能倾斜容器，且 n 的值至少为 2。  
[https://leetcode-cn.com/problems/container-with-most-water/description/](https://leetcode-cn.com/problems/container-with-most-water/description/)    
分析：开始采用暴力法，时间复杂度为O(n^2)  
后来采用双指针方法，小的那一方就移动，遍历一次即可复杂度为O(n)
<pre>
class Solution {
    public int maxArea(int[] height) {
        int area=0,left=0,right=height.length-1;
        while(left< right){
            if(height[left]< height[right]){
                area=Math.max(area,height[left]*(right-left));
                left++;
            }else{
                area=Math.max(area,height[right]*(right-left));
                right--;
            }
        }
        return area;
    }
}</pre>
### 5
题目：给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。  
注意：答案中不可以包含重复的三元组。  
[三数之和](https://leetcode-cn.com/problems/3sum/description/)  
分析：刚开始把题目读错了，认为要去除num[]中的重复，答案错误，使用set，代码:<pre>
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<Integer> numList=new LinkedList<>();
        for(int i=0;i<nums.length;i++){
            numList.add(nums[i]);
        }
        List< List< Integer>> res=new ArrayList< List<Integer>>();
        Set< Integer> set=new HashSet< Integer>(numList);
        nums = new int[set.size()];
        Object[] smallNums =set.toArray();//坑，基本数据类型不能使用此方法
        for(int i=0;i<set.size()-1;i++){
            for(int j=i+1;j<set.size();j++){
                int a=Integer.parseInt(smallNums[i].toString());
                int b=Integer.parseInt(smallNums[j].toString());
                if(-(a+b)==a||-(a+b)==b){
                    continue;
                }
                if(set.contains(-(a+b))){
                    List<Integer> temp=new ArrayList<Integer>();
                    temp.add(a);
                    temp.add(b);
                    temp.add(-(a+b));
                    res.add(temp);
                }
            }
            set.remove(smallNums[i]);
        }
        return res;
    }
}</pre>
正确思路，先排序，使用三指针比较大下,从两端移动,时间复杂度为O(n^2):
<pre>
class So {
    public List<List<Integer>> threeSum(int[] num) {
        Arrays.sort(num);
        List<List<Integer>> res = new LinkedList<>();
        for (int i = 0; i < num.length-2; i++) {
            if(i>0&&num[i]==num[i-1]) continue;
            int low = i+1, hight = num.length-1, sum = 0 - num[i];
            while (low < hight) {
                if (num[low] + num[hight] == sum) {
                    res.add(Arrays.asList(num[i], num[low], num[hight]));
                    while (low < hight && num[low] == num[low + 1]) low++;
                    while (low < hight && num[hight] == num[hight - 1]) hight--;
                    low++; hight--;
                } else if (num[low] + num[hight] < sum) low++;
                else hight--;
            }
        }
        return res;
    }
}
</per>