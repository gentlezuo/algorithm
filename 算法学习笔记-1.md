# 算法学习笔记(刷leetcode笔记)  

### 1
给定一个字符串，找出不含有重复字符的最长子串的长度。  
分析：  
* 暴力法，时间复杂度太大  
* 采用滑动窗口方法,用map标记  
<pre>
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int res=0;
        int length=s.length();
        Map<Character,Integer> map=new HashMap<>();
        for(int i=0,j=0;j< length;j++){
            if(map.containsKey(s.charAt(j))){
                i=Math.max(i,map.get(s.charAt(j))+1);
            }
            map.put(s.charAt(j), j);
            res=Math.max(res,j-i+1);
        }
        return res;
    }
}
</pre>

### 2
给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。  
分析：  
遍历两个链表即可
- 注意链表可能不一样长
- 每一位可能会进位0或1
- 注意遍历完后还可能有一位进位
<pre> /**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int jinwei=0;
        ListNode result=new ListNode(0);
        ListNode res=result;
        while(l1!=null || l2!=null){
            int a= (l1==null) ? 0 : l1.val;
            int b= (l2==null) ? 0 : l2.val;
            if(l1!=null){
                l1=l1.next;
            }
            if(l2!=null){
                l2=l2.next;
            }
            int temp=a+b+jinwei;
            jinwei=temp/10;
            res.next= new ListNode(temp%10);
            res=res.next;
        }
        if(jinwei>0){//判断最后一位进位
            res.next=new ListNode(jinwei);
        }
        return result.next;
    }
}</pre>