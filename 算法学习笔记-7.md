# 算法学习笔记

### 71
题目：给定一个整数 n，返回 n! 结果尾数中零的数量。  
[阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/)  
分析：一个数对其进行因式分解，2的个数总是比5的个数多，10=5*2，因此字需要求出5的个数即可  
代码：
~~~
class Solution {
    public int trailingZeroes(int n) {
        int res=0;
        while(n!=0){
            n/=5;
            res+=n;
        }
        return res;
    }
}
~~~

### 72
题目：颠倒给定的 32 位无符号整数的二进制位。  
[颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/description/)  
分析：可以让res=0开始每次左移一位，n右移一位，使n&1则得到n的从右往左的一位，让这个为与res与这个位或，得到该翻转的数  
第二种方法，直接翻转  
代码：
~~~
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
	//方法1
        /*int res=0;
        for(int i=0;i<32;i++){
            res<<=1;
            res=res|(n&1);
            n>>=1;
        }
        return res;
        */
		//方法2
        String str = Integer.toBinaryString(n);
        StringBuilder sb = new StringBuilder();
        for (int i = str.length() - 1; i >= 0; i--) {
            sb.append(str.charAt(i));
        }
        for (int i = 0; i < 32 - str.length(); i++) {
            sb.append(0);
        }
        return Integer.parseUnsignedInt(sb.toString(), 2);
    }
}
~~~


### 73
题目：编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。  
[位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/description/)  
分析：每次向右移一位，与1，得到改位是否为一，*注意因为输入2147483648对应于java中的-2147483648，如果n = 2147483648条件为n> 0，则代码不会输入while。因此要使用n!=0而非n>0,并且要使用无符号位运算符>>>而不能使用>>*   
代码：
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res=0;
        while(n!=0){
            res+=(n&1);
            n=n>>>1;
        }
        return res;
    }
}
    /*int res=0;
    while(n!=0){
    res++;
    n=n&(n-1);
    }
    return res;
    }
    */
    /*int res=0;    
    String str = Integer.toBinaryString(n);
    for(int i=0;i<str.length();i++){
        if(str.charAt(i)=='1')
            ++res;
    }
        return res;
    } 
    
}
*/
~~~









