# 算法学习笔记

### 71
题目：给定一个整数 n，返回 n! 结果尾数中零的数量。  
[阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/)  
分析：一个数对其进行因式分解，2的个数总是比5的个数多，10=5*2，因此字需要求出5的个数即可  
代码：
~~~
class Solution {
    public int trailingZeroes(int n) {
        int res=0;
        while(n!=0){
            n/=5;
            res+=n;
        }
        return res;
    }
}
~~~

### 72
题目：颠倒给定的 32 位无符号整数的二进制位。  
[颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/description/)  
分析：可以让res=0开始每次左移一位，n右移一位，使n&1则得到n的从右往左的一位，让这个为与res与这个位或，得到该翻转的数  
第二种方法，直接翻转  
代码：
~~~
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
	//方法1
        /*int res=0;
        for(int i=0;i<32;i++){
            res<<=1;
            res=res|(n&1);
            n>>=1;
        }
        return res;
        */
		//方法2
        String str = Integer.toBinaryString(n);
        StringBuilder sb = new StringBuilder();
        for (int i = str.length() - 1; i >= 0; i--) {
            sb.append(str.charAt(i));
        }
        for (int i = 0; i < 32 - str.length(); i++) {
            sb.append(0);
        }
        return Integer.parseUnsignedInt(sb.toString(), 2);
    }
}
~~~


### 73
题目：编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。  
[位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/description/)  
分析：每次向右移一位，与1，得到改位是否为一，*注意因为输入2147483648对应于java中的-2147483648，如果n = 2147483648条件为n> 0，则代码不会输入while。因此要使用n!=0而非n>0,并且要使用无符号位运算符>>>而不能使用>>*   
代码：
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res=0;
        while(n!=0){
            res+=(n&1);
            n=n>>>1;
        }
        return res;
    }
}
    /*int res=0;
    while(n!=0){
    res++;
    n=n&(n-1);
    }
    return res;
    }
    */
    /*int res=0;    
    String str = Integer.toBinaryString(n);
    for(int i=0;i<str.length();i++){
        if(str.charAt(i)=='1')
            ++res;
    }
        return res;
    } 
    
}
*/
~~~

### 74
题目：
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。  
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。   
[ 打家劫舍](https://leetcode-cn.com/problems/house-robber/description/)  
分析：使用动态规划，当前偷或者不偷，取决于前两家的状态，如果偷了，则前一家不能偷，如果不偷，则前一家可偷可不偷  
代码：
~~~
class Solution {
    public int rob(int[] nums) {
        //res[i]=max(res[i-1],res[i-2]+nums[i])
        if(nums==null||nums.length==0) return 0;
        int len=nums.length;
        int[] dp=new int[len+1];
        dp[1]=nums[0];
        for(int i=1;i<len;i++){
            dp[i+1]=Math.max(dp[i],dp[i-1]+nums[i]);
        }
        return dp[len];
    }
	//由于只依赖前两个数，可以不用一个数组而用两个变量代替
	public int rob2(int[] nums)｛
	if(nums==null||nums.length==0) return 0;
        if(nums.length==1) return nums[0];
        if(nums.length==2) return Math.max(nums[0],nums[1]);
        int left=nums[0],right=Math.max(nums[0],nums[1]),curr=0,len=nums.length;
        for(int i=2;i<len;i++){
            curr=Math.max(right,left+nums[i]);
            left=right;
            right=curr;
        }
        return curr;
    }
}
~~~







