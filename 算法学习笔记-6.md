# 算法学习笔记  
### 61
题目：报数序列是指一个整照其中的整数的顺序进数序列，按行报数，得到下一个数。  
[报数](https://leetcode-cn.com/problems/count-and-say/description/)  
分析：依次循环即可。  
代码：
~~~
class Solution {
    public String countAndSay(int n) {
        String s="1";
        for (int i =1 ; i <n ; i++) {
            StringBuffer sb = new StringBuffer();
            int count = 1, j = 0;
            if (s.length() == 1)
                s = "11";
            else {
                while (j < s.length() - 1) {
                    while (j < s.length() - 1 && s.charAt(j) == s.charAt(j + 1)) {
                        count++;
                        j++;
                    }
                    sb.append("" + count + s.charAt(j++));
                    count=1;
                }
                if (s.length() > 1 && s.charAt(s.length()-1) != s.charAt(s.length()-2))
                    sb.append("" + 1 + s.charAt(s.length() - 1));
                s = sb.toString();
            }
        }
        return s;
    }
}
~~~

### 62
题目：给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。  
最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。  
你可以假设除了整数 0 之外，这个整数不会以零开头。  
[加一](https://leetcode-cn.com/problems/plus-one/description/)  
分析：判断是否进位即可，遍历一次   
~~~
class Solution {
    public int[] plusOne(int[] digits) {
        int len=digits.length,jinwei=0;
        digits[len-1]=(digits[len-1]+1)%10;
        if((digits[len-1]==0))
           jinwei=1;
        for(int i=len-2;i>=0;i--){
            int cur=digits[i]+jinwei;
            if(cur/10==1){
                digits[i]=cur%10;
                jinwei=1;
            }else{
                digits[i]=cur;
                return digits;
            }
        }
           if(jinwei==1){
               int[] res=new int[len+1];
               res[0]=1;
               for(int i=1;i<len+1;i++)
                   res[i]=digits[i-1];
               return res;
           }
           return digits;
    }
}
~~~
 
### 63
题目：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。  
[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/description/)  
分析：一遍扫描法  
代码 ；
~~~
class Solution {
    public int maxSubArray(int[] nums) {
        int cursum=nums[0],sum=nums[0];
        for(int i=1;i<nums.length;i++){
            if(cursum<0) cursum=nums[i];
            else cursum+=nums[i];
            if(cursum>sum) sum=cursum;
        }
        return sum;
    }
}
~~~

### 64
题目：给定两个二进制字符串，返回他们的和（用二进制表示）。  
输入为非空字符串且只包含数字 1 和 0。    
[二进制求和](https://leetcode-cn.com/problems/add-binary/description/)  
分析：从后往前遍历，注意最后的进位  
代码：
~~~
public class So {
    public String addBinary(String a, String b) {
        int len1=a.length()-1,len2=b.length()-1,jinwei=0;
        StringBuffer res=new StringBuffer();
        while(len1>=0&&len2>=0){
            int sum=a.charAt(len1--)-'0'+b.charAt(len2--)-'0'+jinwei;
            res.append(sum%2);
            jinwei=sum/2;
        }
        if(len1>=0){
            while(len1>=0){
                int sum=a.charAt(len1--)-'0'+jinwei;
                res.append(sum%2);
                jinwei=sum/2;
            }
        }else if(len2>=0){
            while(len2>=0){
                int sum=b.charAt(len2--)-'0'+jinwei;
                res.append(sum%2);
                jinwei=sum/2;
            }
        }
        if(jinwei>0) res.append("1");
        return res.reverse().toString();
    }
    public String addBinary2(String a, String b) {
        int len1=a.length()-1,len2=b.length()-1,jinwei=0;
        StringBuffer res=new StringBuffer();
        while (len1>=0||len2>=0){
            int sum=jinwei;//good
            if(len1>=0) sum+=a.charAt(len1--)-'0';
            if(len2>=0) sum+=b.charAt(len2--)-'0';
            res.append(sum%2);
            jinwei=sum/2;
        }
        if(jinwei>0) res.append(jinwei);
        return res.reverse().toString();
    }
    public static void main(String[] args){
        So61 so61=new So61();
        so61.addBinary("11","1");
    }
}
~~~

