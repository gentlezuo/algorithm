# 算法学习笔记  
### 61
题目：报数序列是指一个整照其中的整数的顺序进数序列，按行报数，得到下一个数。  
[报数](https://leetcode-cn.com/problems/count-and-say/description/)  
分析：依次循环即可。  
代码：
~~~
class Solution {
    public String countAndSay(int n) {
        String s="1";
        for (int i =1 ; i <n ; i++) {
            StringBuffer sb = new StringBuffer();
            int count = 1, j = 0;
            if (s.length() == 1)
                s = "11";
            else {
                while (j < s.length() - 1) {
                    while (j < s.length() - 1 && s.charAt(j) == s.charAt(j + 1)) {
                        count++;
                        j++;
                    }
                    sb.append("" + count + s.charAt(j++));
                    count=1;
                }
                if (s.length() > 1 && s.charAt(s.length()-1) != s.charAt(s.length()-2))
                    sb.append("" + 1 + s.charAt(s.length() - 1));
                s = sb.toString();
            }
        }
        return s;
    }
}
~~~

### 62
题目：给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。  
最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。  
你可以假设除了整数 0 之外，这个整数不会以零开头。  
[加一](https://leetcode-cn.com/problems/plus-one/description/)  
分析：判断是否进位即可，遍历一次   
~~~
class Solution {
    public int[] plusOne(int[] digits) {
        int len=digits.length,jinwei=0;
        digits[len-1]=(digits[len-1]+1)%10;
        if((digits[len-1]==0))
           jinwei=1;
        for(int i=len-2;i>=0;i--){
            int cur=digits[i]+jinwei;
            if(cur/10==1){
                digits[i]=cur%10;
                jinwei=1;
            }else{
                digits[i]=cur;
                return digits;
            }
        }
           if(jinwei==1){
               int[] res=new int[len+1];
               res[0]=1;
               for(int i=1;i<len+1;i++)
                   res[i]=digits[i-1];
               return res;
           }
           return digits;
    }
}
~~~
 
### 63
题目：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。  
[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/description/)  
分析：一遍扫描法  
代码 ；
~~~
class Solution {
    public int maxSubArray(int[] nums) {
        int cursum=nums[0],sum=nums[0];
        for(int i=1;i<nums.length;i++){
            if(cursum<0) cursum=nums[i];
            else cursum+=nums[i];
            if(cursum>sum) sum=cursum;
        }
        return sum;
    }
}
~~~

### 64
题目：给定两个二进制字符串，返回他们的和（用二进制表示）。  
输入为非空字符串且只包含数字 1 和 0。    
[二进制求和](https://leetcode-cn.com/problems/add-binary/description/)  
分析：从后往前遍历，注意最后的进位  
代码：
~~~
public class So {
    public String addBinary(String a, String b) {
        int len1=a.length()-1,len2=b.length()-1,jinwei=0;
        StringBuffer res=new StringBuffer();
        while(len1>=0&&len2>=0){
            int sum=a.charAt(len1--)-'0'+b.charAt(len2--)-'0'+jinwei;
            res.append(sum%2);
            jinwei=sum/2;
        }
        if(len1>=0){
            while(len1>=0){
                int sum=a.charAt(len1--)-'0'+jinwei;
                res.append(sum%2);
                jinwei=sum/2;
            }
        }else if(len2>=0){
            while(len2>=0){
                int sum=b.charAt(len2--)-'0'+jinwei;
                res.append(sum%2);
                jinwei=sum/2;
            }
        }
        if(jinwei>0) res.append("1");
        return res.reverse().toString();
    }
    public String addBinary2(String a, String b) {
        int len1=a.length()-1,len2=b.length()-1,jinwei=0;
        StringBuffer res=new StringBuffer();
        while (len1>=0||len2>=0){
            int sum=jinwei;//good
            if(len1>=0) sum+=a.charAt(len1--)-'0';
            if(len2>=0) sum+=b.charAt(len2--)-'0';
            res.append(sum%2);
            jinwei=sum/2;
        }
        if(jinwei>0) res.append(jinwei);
        return res.reverse().toString();
    }
    public static void main(String[] args){
        So61 so61=new So61();
        so61.addBinary("11","1");
    }
}
~~~

### 65
题目：给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。  
[杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/description/)  
分析：遍历即可，判断开始是否为零及边界  
代码：
~~~
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res=new ArrayList<>();
        if(numRows==0) return res;
        ArrayList<Integer> temp1=new ArrayList<>();
        temp1.add(1);
        res.add(temp1);
        for (int i = 0; i <numRows - 1 ; i++) {
            ArrayList<Integer> temp=new ArrayList<>();
            temp.add(1);
            for (int j = 0; j <res.get(i).size()-1 ; j++) {
                temp.add(res.get(i).get(j)+res.get(i).get(j+1));
            }
            temp.add(1);
            res.add(temp);
        }
        return res;
    }
}
~~~

### 66
题目：给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。  
[杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/description/)  
分析，申请一个链表依次相加即可，但是要保存要使用的值  
代码：
~~~
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> res=new ArrayList<>(rowIndex+1);
        for (int i = 0; i <rowIndex+1 ; i++) {
            res.add(1);
        }
        for (int i = 0; i <rowIndex ; i++) {
            int temp=res.get(0);
            for (int j = 1; j <=i ; j++) {
                int temp2=res.get(j);
                res.set(j,temp+res.get(j));
                temp=temp2;
            }
        }
        return res;
    }
}
~~~

### 67
题目：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。  
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。  
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。   
[买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/)  
分析：每次选择更大的，不符合，就取当前最大的，接着遍历  
代码：
~~~
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null||prices.length<=1) return 0;
        int i=0,sum=0,j;
        while (i<prices.length-1){
            int one=0;
            for (j = i+1; j <prices.length ; j++) {
                if(prices[j]-prices[i]>one){
                    one=(prices[j]-prices[i]);
                }else
                    break;
            }
            i=j;
            sum+=one;
        }
        return sum;
    }
}
~~~
 

