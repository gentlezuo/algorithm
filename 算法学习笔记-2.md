# 算法学习笔记(算leetcode题)
### 11
题目：假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。  
[ 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/)   
分析：依旧使用二分法即可，不过需要多判断一步nums[left]和nums[right]与nums[med]的大小关系,target在哪个区域就在哪个区域进行二分法。  
代码：<pre> public int search(int[] nums, int target) {
        int left=0,right=nums.length-1;
        while(left<=right){
            int med=(left+right)/2;
            if(target==nums[med]){
                return med;
            }
            if(nums[med]>=nums[left]){
                    if(nums[left]<=target&&target<nums[med]){
                        right= med-1;
                    }else{
                        left = med+1;
                    }
                }else{
                    if(nums[med]<target&&target<=nums[right]){
                        left = med+1;
                    }else{
                        right = med-1;
                    }
                }
        }
        return -1;
    }</pre>
### 12
题目：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。  
你的算法时间复杂度必须是 O(log n) 级别。  
如果数组中不存在目标值，返回 [-1, -1]。   
[在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)  
分析：使用二分法，找到后在前后移动角标直到不等于target  
代码：<pre>class Solution {
    public int[] searchRange(int[] nums, int target) {
        int index=twoSearch(nums,0,nums.length-1,target);
        int[] res=new int[2];
        if(index==-1){
            res[0]=-1;
            res[1]=-1;
            return res;
        }
        else {
            int a = index, b = index;
            while (nums[a] == target) {
                a--;
                if (a <0) break;
            }
            while (nums[b] == target){
                b++;
                if (b >= nums.length) break;
            }
            res[0] = a + 1;
            res[1] = b - 1;
            return res;
        }
    }
    public int twoSearch(int[] nums,int left,int right,int target){
        if(left>right) return -1;
        int mid=(left+right)/2;
        if(target==nums[mid])
            return mid;
        else if(nums[mid]<target)
            return twoSearch(nums,mid+1,right,target);
        else
            return twoSearch(nums,left,mid-1,target);
    }
}</pre>

### 12
题目：判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。  
[有效的数独](https://leetcode-cn.com/problems/valid-sudoku/description/)  
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。  
分析：可以循环三次解决问题效率不高，  
第二种方法：循环一次，是偶用一种方式**标记行和列**，使用set或者其他方式判断是否重复  
代码：<pre>public class Solution {
    public boolean isValidSudoku(char[][] board) {
        Set<String> set=new HashSet<>();
        for(int i=0;i<9;i++){
            for(int j=0;j<9;j++){
                if(board[i][j]!='.'){
                    String temp="("+board[i][j]+")";
                    if(!set.add(i+temp)||!set.add(temp+j)||!set.add(i/3+temp+j/3)){
                        return false;
                    }
                }
            }
        }
        return true;
    }
}</pre>

### 13
题目：给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。  
说明：
所有数字（包括 target）都是正整数。
解集不能包含重复的组合。  
[组合总和](https://leetcode-cn.com/problems/combination-sum/description/)   
分析：使用回溯法，每一次target-nums[i],直到target<0,回溯  
代码<pre>class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> res=new LinkedList<>();
        backtrack(candidates, target, 0, new LinkedList<Integer>(),res);
        return res;
    }
    public void backtrack(int[] nums,int target,int start,List<Integer> list,List<List<Integer>> res){
        if(target==0) {
            res.add(new LinkedList<>(list));//返回上一个函数
        } else {
            for (int i = start; i < nums.length; ++i) {
                if(target-nums[i]>=0) {
                    list.add(nums[i]);
                    backtrack(nums, target - nums[i], i, list, res);
                    //不满足条件或者target==0，删除最后一位，则i++
                    list.remove(list.size() - 1);
                }else {
                    break;
                }
            }
        }
    }   
}</pre>